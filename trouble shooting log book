Trouble Shooting log book

incorrect behaviors discovered:

  -particle movement:
    --particle at LHS (high pressure) edge moves slower (only from n~20 on) than neighboring particles (is passed after n=40 time steps (corresponds to 0.0575s))
    --particle at RHS (low pressure) edge moves only slightly! AND in the wrong direction!!! (to the left instead of to the right)correction: Attention, the particle observed, was not the very last particle(x=1.99) but the second last particle (x=1.975) as it was not shown in the diagramm (==>CORRECTION IMPLEMENTED 20100713,particle movement examined again, observations: last particle moves in the right direction, but neighbors remain almost without movement)

    --particle at interface (x=1) does (almost) not move at all (and is passed at n=23), besides 11th last particle on high pressure side before interface (x=0.981...) seems to be the center of a divergent particle movement pattern!?!?

  -other particle properties
    --there is no formation (at least: no propagation) of a shock front and of a rarefaction wave. Instead the discontinuity in pressure remains at around x=1 and errors are produced...

possible causes, errors in the code:

  -particle mass is initiated by smoothing (and not directly assigned at the beginning like in 1DSPH code)
  Rem: exact value of mass is wrong, should be 1.875e-03. But this is only because the kernel with 2d normation factor is used (instead of 1D)
(LHS edge)4.94801e-05	(LHS)4.12334e-0	(IF)9.16298e-06	(IF)6.47179e-05	(RHS)4.12334e-05  (RHS edge)7.61232e-05
  -->could this not uniform mass distribution contribute to the mess??? Probably not, but I will try constant mass anyway.

    CONSTANT MASS  (m=0.00185 (1D value), leads to different values in rho, p, but those are still initialized with 1D values, to get rid of this influence 1D kernel factors have to be implemented!!!) IMPLEMENTED 20100713:
    
      RESULTS:
	==>LHS: edge particle is also passed around @ n=37
	==>IF: 	particle at the very interface is only passed after n=71 (instead of n=23)
		divergent particle movement around 11th particle has disappeared
	==>RHS: no big difference, neighbor particle begins to move in the right direction @ around n=70...

  

  -PARTICLE MANAGER could  "forget" particles when transfering it from one cell to another!?!
    --therefore: detecting cell interface locations and look for link between them and the places where strange particle behaviour occurrs
  -no boundary condition (free edge) is implemented, see how particle manager handles particles at the very edge
    ==>cell linked list created by particle manager: "cell_lists" with size of cell size from initiation file +2 (because of boundary particles in general)
    

    the following methods for PARTICLE MANAGER are TESTED

	*BuildRealParticle:
	  + particles are all read from initiation file, created in the program and have the right initial values
	  + check where particles are inserted in particle list (cell size 0.05, final nb of cells in x: 42, y:3)
	      -test particle 1: (x=0,y=0) -->i=1,j=1 (where i is the cell number in x direction (0-41), j in y direction (0-2);
	      -test particle 2: (x=0.07,y=0) -->i=2,j=1 (where i is the cell number in x direction (0-41), j in y direction (0-2);
	      -test particle 3: (x=1.99,y=0) -->i=40,j=1 (where i is the cell number in x direction (0-41), j in y direction (0-2);
	  OKAY!


	*BuildNPP:
	  *NPP_list for the particle in question is created
	  method not used in the program->NO INFLUENCE!

	*constructor:
	*UpdateCellLinkedLists:
      
	*BuildInteraction:
	  in line 174 the conditions 0<position<2: they lead to the fact that particles leaving this domain are not taken intoaccount any more for interactions. This makes the neighboring particles move faster (as for them, they don't exist any more-->they pass the edge particle.)

	    Problem: if I want to remove this restriction and let the particles flow out of the domain 0<pos<2, there is an error in line 183 as soon as the particles position becomes <0 as the indx i of the list would become negative!!
	    (for the case with boundary conditions, this is not a problem as a negative position will never occurr (particles are copied and reinserted according to their boundary condition once they leave the domain ).

	    -->one possible SOLUTION: move the calculation domain from 0---2 to 1---3!
	    Attention: cell numeration starts at 0 for the first cell which mandatory is in position x=0. To cover the whole domain we need at least until x=3.
	    With this solution implemented, the particles at the edge of the domain move as phsyically predicted and there is no passing of particles any more.
	    The simulation will report an error as soon as the first particle has moved out of the domain covered by cells (in the current form I have used 7 cells with a size of 0.5 each and thus ranging from 0 - 3.5) NOW: LATER VERSION: 130 cells with size 0.03 covers 0 - 3.9) (0.03 is the optimum cell size, as size = supportlength)
	    
	    HOWEVER the particle movement at the interface still is not as it should. One possible reason for this can be due to an erroneous ARTIFICIAL VISCOSITY implementation/calculation.
	    

	  + neighboring particle search:
	    results of interaction list for first time step compared to 1DSPH code...OKAY!
	    at this occasion the smoothing function and derivative calculation in CUBICSPLINE.cpp has been verified by comparing to the 1DSPH values. As a first step a 1D kernel is implemented and I adapted the factors. I have detected an (probable) error at the call of the dW method: instead of the normalized vector eij, the normal distance vecetor rij was given as an argument. The correction of this error leads to new dW results which on the other hand lead to higher change rates and a more realistic (as faster, in accordance to 1DSPH) particle movement....now OKAY!

	    
	(*BuildWallParticle:)

The comparison of the Art. Visc. between 1DSPH and the big code results in small differences. As the actual formula for the art.vis. calculation is good, there must probably be an error with the values used in this equation. one possible source of error might be the integration scheme!?!(1DSPH uses leapfrog, the big code predictor corrector). Anyway, to allow for better comparison of the two (even if the error does not lie in the integrator) I will try to implement the leap frog scheme in the big code.

As particle manager seems to be OKAY, the hext method examined will be the time integration method. (perhaps the predictor/corrector step does not work for discontinuities/shocks? and a leap frog scheme would work better!?!

  

  -